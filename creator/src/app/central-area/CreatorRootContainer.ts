import RootContainer from '@shared/layout/RootContainer';
import CreatorContainer from './CreatorContainer';
import LayoutState from '@shared/animation/LayoutState';
import EqComponent from '@shared/layout/EqComponent';
import Radical from '@shared/layout/Radical';
import { creatorContainerAddClick, creatorContainerCreatorDraw, childrenToStepLayout } from './CreatorContainerMethods';
import CanvasController from '@shared/main/CanvasController';
import { RootContainerFormat } from '@shared/main/FileFormat';
import EqContent from '@shared/layout/EqContent';
import { creatorContainerPadding, creatorContainerStroke } from '@shared/main/consts';
import { Container } from '@shared/main/ComponentModel';
import CreatorHBox from './CreatorHBox';
import { parseContainerChildren } from '@shared/main/helpers';

@Container({
    typeString: 'creator-root',
    parse: (containerObj, depth, contentGetter, containerGetter, genInfo) => {
        const format = containerObj as RootContainerFormat;
        const idx = new CreatorHBox(
            parseContainerChildren(format.idx, depth, containerGetter, contentGetter),
            creatorContainerPadding
        );
        const arg = new CreatorHBox(
            parseContainerChildren(format.arg, depth, containerGetter, contentGetter),
            creatorContainerPadding
        );
        let radical: Radical;
        if (format.rad) {
            radical = contentGetter(format.rad) as Radical;
        }
        return new CreatorRootContainer(idx, arg, radical, creatorContainerPadding, (genInfo as any).termHeights);
    }
})
export default class CreatorRootContainer extends RootContainer implements CreatorContainer {
    /**
     * When this container is clicked,
     * add a component to it at some
     * position. This default implementation
     * adds the component adjacent to this one
     * in the parent container of this container.
     * @param clickedLayout The layout state (generated by this container) that was clicked.
     * @param x The x-ordinate clicked.
     * @param y The y-ordinate clicked.
     * @param toAdd The component to add.
     */
    addClick(l: LayoutState, x: number, y: number, toAdd: EqComponent<any>) {
        const pad = creatorContainerPadding.scale(l.scale);
        // Make fake layout state to use like rectangles
        const inner = new LayoutState(
            undefined,
            undefined,
            l.tlx + pad.left,
            l.tly + pad.top,
            l.width - pad.width(),
            l.height - pad.height(),
            1
        );
        if (inner.contains(x, y)) {
            if (!(toAdd instanceof Radical)) {
                throw new Error('Only Radicals can be added to a Root Container.');
            }
            this.radical = toAdd;
        } else {
            creatorContainerAddClick.call(this, l, x, y, toAdd);
        }
    }

    creatorDraw(l: LayoutState, ctx: CanvasRenderingContext2D) {
        ctx.save();
        ctx.strokeStyle = creatorContainerStroke;

        // Outer border
        ctx.beginPath();
        ctx.rect(l.tlx, l.tly, l.width, l.height);
        ctx.stroke();

        ctx.restore();
        creatorContainerCreatorDraw.call(this, l, ctx);
    }

    /**
     * When one of this container's direct
     * children is clicked, add a component
     * adjacent to the clicked child.
     * @param clickedLayout The layout state generated by the child.
     * @param x The x-ordinate clicked.
     * @param y The y-ordinate clicked.
     * @param toAdd The component to add.
     */
    addClickOnChild(clickedLayout: LayoutState, x: number, y: number, toAdd: EqComponent<any>) {
        return;
    }

    /**
     * Returns an object representing
     * the step layout that would generate
     * this container.
     */
    toStepLayout(controller: CanvasController): RootContainerFormat {
        const toReturn: any = {};
        toReturn.type = 'root';
        toReturn.idx = childrenToStepLayout(this.index.getChildren(), controller);
        toReturn.arg = childrenToStepLayout(this.argument.getChildren(), controller);
        if (this.radical) {
            toReturn.rad = this.radical.getRef();
        }
        return toReturn;
    }

    /**
     * Delete a child of this container.
     * @param toDelete The child to delete.
     */
    delete(toDelete: EqComponent<any>) {
        if (toDelete === this.radical) {
            this.radical = undefined;
        }
    }

    /**
     * Runs a function for every piece of
     * content under this container.
     * @param forEach The function to run for content.
     */
    forEachUnder(forEach: (content: EqContent<any>) => void) {
        (this.index as unknown as CreatorContainer).forEachUnder(forEach);
        (this.argument as unknown as CreatorContainer).forEachUnder(forEach);
        if (this.radical) {
            forEach(this.radical);
        }
    }

    setRadical(newRadical: Radical) {
        this.radical = newRadical;
    }

    /**
     * Whether this container lays out components vertically
     * and more can be added.
     */
    addVertically(): boolean {
        return false;
    }

    /**
     * Whether this container lays out components horizontally
     * and more can be added.
     */
    addHorizontally(): boolean {
        return false;
    }

    /**
     * Add a child before another.
     * @param toAdd The child to add.
     * @param before Add before this child.
     */
    addBefore(toAdd: EqComponent<any>, before: EqComponent<any>) {
        return;
    }

    /**
     * Add a child after another.
     * @param toAdd The child to add.
     * @param after Add after this child.
     */
    addAfter(toAdd: EqComponent<any>, after: EqComponent<any>) {
        return;
    }
}
