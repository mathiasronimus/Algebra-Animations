import TableContainer, { parseChildren2D, parseChildrenObj } from '@shared/layout/TableContainer';
import CreatorContainer from './CreatorContainer';
import LayoutState from '@shared/animation/LayoutState';
import EqComponent from '@shared/layout/EqComponent';
import CanvasController from '@shared/main/CanvasController';
import { ContainerFormat, TableFormat } from '@shared/main/FileFormat';
import EqContent from '@shared/layout/EqContent';
import EqContainer from '@shared/layout/EqContainer';
import HDivider from '@shared/layout/HDivider';
import VDivider from '@shared/layout/VDivider';
import { line } from '@shared/main/helpers';
import { creatorContainerCreatorDraw, creatorContainerAddClick } from './CreatorContainerMethods';
import Radical from '@shared/layout/Radical';
import {
    creatorTableMinCellDimen,
    creatorContainerStroke,
    creatorLineDash,
    creatorPlusLineHalfLength,
    creatorContainerPadding,
} from '@shared/main/consts';
import { Container } from '@shared/main/ComponentModel';
import Padding from '@shared/layout/Padding';

@Container({
    typeString: 'creator-table',
    parse: (containerObj, depth, contentGetter, containerGetter, inf) => {
        // Not selectable
        const format = containerObj as TableFormat;
        return new CreatorTable(
            creatorContainerPadding,
            parseChildren2D(format.children, containerGetter, contentGetter),
            parseChildrenObj(format.hLines, contentGetter),
            parseChildrenObj(format.vLines, contentGetter),
            11,
            Padding.even(0)
        );
    }
})
export default class CreatorTable extends TableContainer implements CreatorContainer {
    /**
     * Return the mimimum dimension in either axis
     * for a table cell.
     */
    protected getMinCellDimen(): number {
        return creatorTableMinCellDimen;
    }

    getHLines(): { [index: number]: EqComponent<any> } {
        return this.hLines;
    }

    getVLines(): { [index: number]: EqComponent<any> } {
        return this.vLines;
    }

    getChildren(): EqComponent<any>[][] {
        return this.children;
    }

    /**
     * When one of this container's direct
     * children is clicked, add a component
     * adjacent to the clicked child.
     * @param clickedLayout The layout state generated by the child.
     * @param x The x-ordinate clicked.
     * @param y The y-ordinate clicked.
     * @param toAdd The component to add.
     */
    addClickOnChild(clickedLayout: LayoutState, x: number, y: number, toAdd: EqComponent<any>): void {
        // Not valid in any case
        return;
    }

    /**
     * Returns an object representing
     * the step layout that would generate
     * this container.
     */
    toStepLayout(controller: CanvasController): ContainerFormat {
        // Convert 2d array of components to 2d array to save
        const saveChildren = [];
        for (const row of this.children) {
            const rowArr = [];
            for (const currChild of row) {
                if (currChild) {
                    if (currChild instanceof EqContainer) {
                        const stepLayout = (currChild as unknown as CreatorContainer).toStepLayout(controller);
                        rowArr.push(stepLayout);
                    } else if (currChild instanceof EqContent) {
                        rowArr.push(currChild.getRef());
                    }
                } else {
                    rowArr.push(null);
                }
            }
            saveChildren.push(rowArr);
        }

        // Convert vLines to step format
        const saveVLines = {};
        Object.keys(this.vLines).forEach(index => {
            const component = this.vLines[index];
            saveVLines[index] = (component as EqContent<any>).getRef();
        });

        // Convert hLines to step format
        const saveHLines = {};
        Object.keys(this.hLines).forEach(index => {
            const component = this.hLines[index];
            saveHLines[index] = (component as EqContent<any>).getRef();
        });

        const toReturn = {
            type: 'table',
            children: saveChildren,
            vLines: saveVLines,
            hLines: saveHLines
        } as TableFormat;
        return toReturn;
    }

    /**
     * Delete a child of this container.
     * @param toDelete The child to delete.
     */
    delete(toDelete: EqComponent<any>): void {
        // Deleting always valid
        if (toDelete instanceof HDivider) {
            // Find the hDivider and delete it
            for (const index of Object.keys(this.hLines)) {
                const hDivider = this.hLines[index];
                if (hDivider === toDelete) {
                    // Found it
                    delete this.hLines[index];
                    return;
                }
            }
            throw new Error('HDivider not found');
        } else if (toDelete instanceof VDivider) {
            // Find the vDivider and delete it
            for (const index of Object.keys(this.vLines)) {
                const vDivider = this.vLines[index];
                if (vDivider === toDelete) {
                    // Found it
                    delete this.vLines[index];
                    return;
                }
            }
            throw new Error('VDivider not found');
        } else {
            // Must be in children array
            for (const row of this.children) {
                for (let c = 0; c < row.length; c++) {
                    const currChild = row[c];
                    if (currChild === toDelete) {
                        // Found it
                        row[c] = null;
                        return;
                    }
                }
            }
            throw new Error('Child not found');
        }
    }

    /**
     * Runs a function for every piece of
     * content under this container.
     * @param forEach The function to run for content.
     */
    forEachUnder(forEach: (content: EqContent<any>) => void): void {
        Object.keys(this.hLines).forEach(index => {
            // tslint:disable-next-line:no-shadowed-variable
            const line = this.hLines[index];
            forEach(line);
        });
        Object.keys(this.vLines).forEach(index => {
            // tslint:disable-next-line:no-shadowed-variable
            const line = this.vLines[index];
            forEach(line);
        });
        for (const row of this.children) {
            for (const currChild of row) {
                if (currChild) {
                    if (currChild instanceof EqContent) {
                        forEach(currChild);
                    } else if (currChild instanceof EqContainer) {
                        (currChild as EqContainer<any> & CreatorContainer).forEachUnder(forEach);
                    }
                }
            }
        }
    }

    /**
     * Whether this container lays out components vertically
     * and more can be added.
     */
    addVertically(): boolean {
        return false;
    }

    /**
     * Whether this container lays out components horizontally
     * and more can be added.
     */
    addHorizontally(): boolean {
        return false;
    }

    /**
     * Add a child before another.
     * @param toAdd The child to add.
     * @param before Add before this child.
     */
    addBefore(toAdd: EqComponent<any>, before: EqComponent<any>): void {
        return;
    }

    /**
     * Add a child after another.
     * @param toAdd The child to add.
     * @param after Add after this child.
     */
    addAfter(toAdd: EqComponent<any>, after: EqComponent<any>): void {
        return;
    }

    /**
     * When this container is clicked,
     * add a component to it at some
     * position. This default implementation
     * adds the component adjacent to this one
     * in the parent container of this container.
     * @param clickedLayout The layout state (generated by this container) that was clicked.
     * @param x The x-ordinate clicked.
     * @param y The y-ordinate clicked.
     * @param toAdd The component to add.
     */
    addClick(clickedLayout: LayoutState, x: number, y: number, toAdd: EqComponent<any>): void {
        // Generate some fake layout states where children
        // or lines were NOT created.
        const emptyChildLayouts: LayoutState[][] = [];
        const emptyVLineLayouts: LayoutState[] = [];
        const emptyHLineLayouts: LayoutState[] = [];

        let upToY = clickedLayout.tly + this.padding.top + this.getLineStroke();
        for (let r = 0; r < this.children.length; r++) {
            // Do the row
            let upToX = clickedLayout.tlx + this.padding.left + this.getLineStroke();
            const rowHeight = this.heights[r];

            // Add hline placeholder before row if there is one
            if (!this.hLines[r]) {
                emptyHLineLayouts[r] = new LayoutState(
                    undefined, undefined,
                    clickedLayout.tlx + this.padding.left, upToY - this.getLineStroke(),
                    clickedLayout.width - this.padding.width(), this.getLineStroke(), 1
                );
            }

            emptyChildLayouts[r] = [];

            for (let c = 0; c < this.children[r].length; c++) {
                // Do each column
                const colWidth = this.widths[c];

                // Add vline placeholder before column if there is one
                if (!this.vLines[c]) {
                    emptyVLineLayouts[c] = new LayoutState(
                        undefined, undefined,
                        upToX - this.getLineStroke(), clickedLayout.tly + this.padding.top,
                        this.getLineStroke(), clickedLayout.height - this.padding.height(), 1
                    );
                }

                const currChild = this.children[r][c];
                if (!currChild) {
                    // Add child layout placeholder
                    emptyChildLayouts[r][c] = new LayoutState(
                        undefined, undefined,
                        upToX, upToY, colWidth, rowHeight, 1
                    );
                }
                upToX += colWidth + this.getLineStroke();

                // Add vline placeholder after last column if there is one
                if (c === this.children[r].length - 1 && !this.vLines[c + 1]) {
                    emptyVLineLayouts[c + 1] = new LayoutState(
                        undefined, undefined,
                        upToX - this.getLineStroke(), clickedLayout.tly + this.padding.top,
                        this.getLineStroke(), clickedLayout.height - this.padding.height(), 1
                    );
                }
            }
            upToY += rowHeight + this.getLineStroke();

            // Add hline placeholder before row if there is one
            if (r === this.children.length - 1 && !this.hLines[r + 1]) {
                emptyHLineLayouts[r + 1] = new LayoutState(
                    undefined, undefined,
                    clickedLayout.tlx + this.padding.left, upToY - this.getLineStroke(),
                    clickedLayout.width - this.padding.width(), this.getLineStroke(), 1
                );
            }
        }

        // Check if the click was on any of the placeholders
        for (let r = 0; r < this.children.length; r++) {
            for (let c = 0; c < this.children[r].length; c++) {
                if (emptyChildLayouts[r][c] && emptyChildLayouts[r][c].contains(x, y)) {
                    // Click was on this placeholder
                    // Some content types not allowed
                    if (toAdd instanceof Radical) {
                        throw new Error('Cannot add that here');
                    } else if (toAdd instanceof HDivider) {
                        throw new Error('Cannot add that here');
                    } else if (toAdd instanceof VDivider) {
                        throw new Error('Cannot add that here');
                    }
                    this.children[r][c] = toAdd;

                    return;
                }
            }
        }

        // Check if the click was on any h lines
        for (let r = 0; r <= this.children.length; r++) {
            if (emptyHLineLayouts[r] && emptyHLineLayouts[r].contains(x, y)) {
                // Click was on this placeholder
                // Only an hLine is allowed to be added
                if (!(toAdd instanceof HDivider)) {
                    throw new Error('Only Horizontal Lines can be added here.');
                }
                this.hLines[r] = toAdd;
                return;
            }
        }

        // Check if the click was on any v lines
        for (let c = 0; c <= this.children[0].length; c++) {
            if (emptyVLineLayouts[c] && emptyVLineLayouts[c].contains(x, y)) {
                // Click was on this placeholder
                // Only an hLine is allowed to be added
                if (!(toAdd instanceof VDivider)) {
                    throw new Error('Only Vertical Lines can be added here.');
                }
                this.vLines[c] = toAdd;
                return;
            }
        }

        // If get to here, couldn't find anything else.
        creatorContainerAddClick.call(this, clickedLayout, x, y, toAdd);
    }

    /**
     * Draws the container on the canvas,
     * only used in the creator. This default
     * implementation draws carets on the outer
     * half of the padding, depending on the
     * parent container.
     * @param l The layout of this container.
     * @param ctx The graphics context to draw to.
     */
    creatorDraw(l: LayoutState, ctx: CanvasRenderingContext2D): void {
        ctx.save();

        // Draw an outline
        ctx.strokeStyle = creatorContainerStroke;
        ctx.strokeRect(l.tlx, l.tly, l.width, l.height);

        // If any lines are not present, draw them as dotted lines
        const hLinesToDraw = new Set();
        for (let r = 0; r <= this.children.length; r++) {
            if (!this.hLines[r]) {
                hLinesToDraw.add(r);
            }
        }

        const vLinesToDraw = new Set();
        for (let c = 0; c <= this.children[0].length; c++) {
            if (!this.vLines[c]) {
                vLinesToDraw.add(c);
            }
        }

        // Draw h lines
        ctx.save();
        ctx.setLineDash(creatorLineDash);
        ctx.strokeStyle = creatorContainerStroke;
        let upToY = l.tly + this.padding.top;
        for (let r = 0; r <= this.children.length; r++) {
            if (hLinesToDraw.has(r)) {
                line(l.tlx + this.padding.left,
                    upToY + this.getLineStroke() / 2,
                    l.tlx + l.width - this.padding.right,
                    upToY + this.getLineStroke() / 2, ctx);
            }
            upToY += this.getLineStroke() + this.heights[r];
        }

        // Draw v lines
        let upToX = l.tlx + this.padding.left;
        for (let c = 0; c <= this.children[0].length; c++) {
            if (vLinesToDraw.has(c)) {
                line(upToX + this.getLineStroke() / 2,
                    l.tly + this.padding.top,
                    upToX + this.getLineStroke() / 2,
                    l.tly + l.height - this.padding.bottom, ctx);
            }
            upToX += this.getLineStroke() + this.widths[c];
        }
        ctx.restore();

        // Draw a small plus in the center of any cell not
        // occupied.
        upToY = l.tly + this.padding.top + this.getLineStroke();
        for (let r = 0; r < this.children.length; r++) {
            // Do the row
            upToX = l.tlx + this.padding.left + this.getLineStroke();
            const rowHeight = this.heights[r];
            for (let c = 0; c < this.children[r].length; c++) {
                // Do each column
                const colWidth = this.widths[c];

                const currChild = this.children[r][c];
                if (!currChild) {
                    // Draw plus
                    ctx.save();
                    ctx.translate(upToX + colWidth / 2, upToY + rowHeight / 2);
                    ctx.strokeStyle = creatorContainerStroke;
                    line(-creatorPlusLineHalfLength, 0, creatorPlusLineHalfLength, 0, ctx);
                    line(0, -creatorPlusLineHalfLength, 0, creatorPlusLineHalfLength, ctx);
                    ctx.restore();
                }
                upToX += colWidth + this.getLineStroke();
            }
            upToY += rowHeight + this.getLineStroke();
        }

        ctx.restore();

        // Carets that depend on parent
        creatorContainerCreatorDraw.call(this, l, ctx);
    }

}
